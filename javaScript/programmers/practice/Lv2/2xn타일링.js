//  2xn타일링
//  정확성: ⭕
//  효율성: ⭕
//  시간: 30분
//  아쉬운점: 이것이 쉬운 dp 문제라는 것을 대충 알고 있었음

// 1시 49분
//  제한사항을 보면 dp 문제 같음 헉!

function solution(n) {
  let answer = 0;
  let dp = [];
  dp[0] = 1;
  dp[1] = 1;
  dp[2] = 2;

  for (let i = 2; i <= n; i++) {
    dp[i] = (dp[i - 2] % 1000000007) + (dp[i - 1] % 1000000007);
  }

  // n이 홀수 일 때
  // 가로는 최소 2개 최대 n-1개 (0, 2, 4, 6 ...n-1) 가로와 세로라는 같은 수의 순열
  //                   세로는 (n, n-2, n-4 ... 1); 세로도 같은 수의 순열
  //  대신 가로는 전체 n에 - 1(가로수) 이렇게 해야 함
  // n이 1일 때 1 / 1 dp[1] = 1;
  // n이 2일 때 가로 2개 1/1 +  세로2개 2/2 dp[2] = 2;
  // n이 3일 때 세로 3개 = 1 +  가로2개 세로1개 = 2/1*1 dp[3] = 3;
  // n이 4일 때 세로 4개 =1 + 세로2개, 1개(가로 2개) 3!/2  + 1개(가로 2개) 2/2 = 1 + 세로 4개 = 1 ;
  // n이 5일 때
  // 세로 5개 1
  // 세로 3개 가로 1개(2개) 4!/3! = 4
  // 세로 1개 가로 2개(4개) 3!/2! = 3
  //  8개
  // n 6일때
  // 세로6개 1
  //  세로 4개 1개(가로2개)  -> 5!/4 5321 15
  //  세로 2개 2개(가로2개) 4!/2 2 6
  // 21개?

  return dp[n] % 1000000007;
}
